#!/bin/bash

## Text colors and styles
info() {
	tput sgr0; tput setaf 2; tput bold
	echo "$1"
	tput sgr0
}
info_2() {
	tput sgr0; tput setaf 2
	echo -n "	$1"
	tput sgr0
}
info_3() {
	tput sgr0; tput setaf 2
	echo -e -n "\r\e[K$1"
	tput sgr0
}
boring_text() {
	tput sgr0; tput setaf 7; tput dim
	echo "$1"
	tput sgr0
}
need_input() {
	tput sgr0; tput setaf 6 ; tput bold
	echo "$1" 1>&2
	tput sgr0
}
warn() {
	tput sgr0; tput setaf 3
	echo "$1" 1>&2
	tput sgr0
}
fail() {
	tput sgr0; tput setaf 1; tput bold
	echo "$1" 1>&2
	tput sgr0
}
fail_3() {
	tput sgr0; tput setab 1; tput setaf 7; tput bold
	echo -e -n  "\r\e[K$1" 1>&2
	tput sgr0
}
fail_exit() {
	tput sgr0; tput setaf 1; tput bold
	echo "$1" 1>&2
	tput sgr0
	exit 1
}
seperator() {
	echo -e "\n"
	echo $(printf '%*s' "$(tput cols)" | tr ' ' '=')
	echo -e "\n"
}

## System Update and Install Dependencies
update() {
    info "正在更新系统..."
    apt-get -qqy update && apt-get -qqy upgrade

    # Install Dependencies
    info "安装基础依赖..."
	if [ -z $(which sudo) ]; then
		apt-get install sudo -qqy
		if [ $? -ne 0 ]; then
			fail_exit "Sudo Installation Failed"
		fi
	fi
	if [ -z $(which wget) ]; then
		apt-get install wget -qqy
		if [ $? -ne 0 ]; then
			fail_exit "Wget Installation Failed"
		fi
	fi
	if [ -z $(which curl) ]; then
		apt-get install curl -qqy
		if [ $? -ne 0 ]; then
			fail_exit "Curl Installation Failed"
		fi
	fi
	if [ -z $(which sysstat) ]; then
		apt-get install sysstat -qqy
		if [ $? -ne 0 ]; then
			fail_exit "Sysstat Installation Failed"
		fi
	fi
	if [ -z $(which psmisc) ]; then
		apt-get install psmisc -qqy
		if [ $? -ne 0 ]; then
			fail_exit "Psmisc Installation Failed"
		fi
	fi
	info "基础依赖安装完成"
	return 0
}

# 应用程序安装模块
# AutoBrr安装函数
install_autobrr() {
    need_input "请输入用户名："
    read username
    
    if [ -z "$username" ]; then
        fail "未设置用户名"
        return 1
    fi
    
    if [ -z "$(getent passwd $username)" ]; then
        need_input "用户不存在，是否创建用户？(y/n)"
        read create_user
        if [[ "$create_user" == "y" || "$create_user" == "Y" ]]; then
            adduser --gecos "" $username
        else
            fail "用户不存在"
            return 1
        fi
    fi
    
    need_input "请输入AutoBrr端口号 [7474]："
    read autobrr_port
    autobrr_port=${autobrr_port:-7474}
    
    info "正在安装AutoBrr..."
    
    ## Install AutoBrr
    # Check CPU architecture
    if [ $(uname -m) == "x86_64" ]; then
        wget $(curl -s https://api.github.com/repos/autobrr/autobrr/releases/latest | grep download | grep linux_x86_64 | cut -d\" -f4)
    elif [ $(uname -m) == "aarch64" ]; then
        wget $(curl -s https://api.github.com/repos/autobrr/autobrr/releases/latest | grep download | grep linux_arm64.tar | cut -d\" -f4)
    else
        fail "AutoBrr download failed"
        return 1
    fi
    # Exit if download fail
    if [ ! -f autobrr*.tar.gz ]; then
        fail "AutoBrr download failed"
        return 1
    fi
    sudo tar -C /usr/bin -xzf autobrr*.tar.gz
    # Exit if extraction fail
    if [ $? -ne 0 ]; then
        fail "AutoBrr extraction failed"
        rm autobrr*.tar.gz
        return 1
    fi
    mkdir -p /home/$username/.config/autobrr
    secret_session_key=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c16)
    cat << EOF >/home/$username/.config/autobrr/config.toml
# Hostname / IP
#
# Default: "localhost"
#
host = "0.0.0.0"

# Port
#
# Default: 7474
#
port = $autobrr_port

# Base url
# Set custom baseUrl eg /autobrr/ to serve in subdirectory.
# Not needed for subdomain, or by accessing with the :port directly.
#
# Optional
#
#baseUrl = "/autobrr/"

# autobrr logs file
# If not defined, logs to stdout
#
# Optional
#
#logPath = "log/autobrr.log"

# Log level
#
# Default: "DEBUG"
#
# Options: "ERROR", "DEBUG", "INFO", "WARN", "TRACE"
#
logLevel = "DEBUG"

# Log Max Size
#
# Default: 50
#
# Max log size in megabytes
#
#logMaxSize = 50

# Log Max Backups
#
# Default: 3
#
# Max amount of old log files
#
#logMaxBackups = 3

# Check for updates
#
checkForUpdates = true

# Session secret
# Can be generated by running: head /dev/urandom | tr -dc A-Za-z0-9 | head -c16
sessionSecret = "$secret_session_key"

# Custom definitions
#
#customDefinitions = "/home/$YOUR_USER/.config/autobrr/definitions"
EOF
    chown -R $username /home/$username/.config/autobrr
    # Create AutoBrr service
    touch /etc/systemd/system/autobrr@.service
    cat << EOF >/etc/systemd/system/autobrr@.service
[Unit]
Description=autobrr service
After=syslog.target network-online.target

[Service]
Type=simple
User=$username
Group=$username
ExecStart=/usr/bin/autobrr --config=/home/$username/.config/autobrr/

[Install]
WantedBy=multi-user.target
EOF
    # Enable and start AutoBrr
    systemctl enable autobrr@$username
    systemctl start autobrr@$username
    # Clean up
    rm autobrr*.tar.gz
    
    # Check if AutoBrr is running
    if [ -z $(pgrep autobrr) ]; then
        fail "AutoBrr failed to start"
        return 1
    fi

    info "AutoBrr安装完成，访问 http://你的IP:$autobrr_port 使用"
    return 0
}

# Vertex安装函数
install_vertex() {
    need_input "请输入用户名："
    read username
    
    need_input "请输入密码："
    read -s password
    
    if [[ -z "$username" ]] || [ -z "$password" ]; then
        fail "用户名或密码未设置"
        return 1
    fi
    
    need_input "请输入Vertex端口号 [3000]："
    read vertex_port
    vertex_port=${vertex_port:-3000}
    
    info "正在安装Vertex..."
    
    #Check if docker is installed
    if [ -z $(which docker) ]; then
        curl -fsSL https://get.docker.com -o get-docker.sh
        # Check if download fail
        if [ ! -f get-docker.sh ]; then
            fail "Docker download failed"
            return 1
        fi
        sh get-docker.sh
        # Check if installation fail
        if [ $? -ne 0 ]; then
            fail "Docker installation failed"
            rm get-docker.sh
            return 1
        fi
    else
        #Check if Docker image vertex is installed
        if [ -n $(docker images | grep vertex | grep -v grep) ]; then
            fail "Vertex already installed"
            return 1
        fi
    fi
    ## Install Vertex
    if [ -z $(which apparmor) ]; then
        apt-get -y install apparmor
        #Check if install is successful
        if [ $? -ne 0 ]; then
            fail "Apparmor Installation Failed"
            return 1
        fi
    fi
    if [ -z $(which apparmor-utils) ]; then
        apt-get -y install apparmor-utils
        #Check if install is successful
        if [ $? -ne 0 ]; then
            fail "Apparmor-utils Installation Failed"
            return 1
        fi
    fi
    timedatectl set-timezone Asia/Shanghai
    mkdir -p /root/vertex
    chmod 755 /root/vertex
    docker run -d --name vertex --restart unless-stopped -v /root/vertex:/vertex -p $vertex_port:3000 -e TZ=Asia/Shanghai lswl/vertex:stable
    sleep 5s
    # Check if Vertex is running
    if ! [ "$( docker container inspect -f '{{.State.Status}}' vertex 2>/dev/null)" = "running" ]; then
        fail "Vertex failed to start"
        return 1
    fi
    # Set username & password
    docker stop vertex
    sleep 5s
    # Confirm it is stopped
    if ! [ "$( docker container inspect -f '{{.State.Status}}' vertex 2>/dev/null)" = "exited" ]; then
        fail "Vertex failed to stop"
        return 1
    fi
    # Set username & password
    vertex_pass=$(echo -n $password | md5sum | awk '{print $1}')
    mkdir -p /root/vertex/data
    cat << EOF >/root/vertex/data/setting.json
{
  "username": "$username",
  "password": "$vertex_pass"
}
EOF
    # Start Vertex
    docker start vertex
    sleep 5s
    # Check if Vertex has restarted
    if ! [ "$( docker container inspect -f '{{.State.Status}}' vertex 2>/dev/null)" = "running" ]; then
        fail "Vertex failed to start"
        return 1
    fi
    # Clean up
    if [ -f get-docker.sh ]; then
        rm get-docker.sh
    fi
    
    info "Vertex安装完成，访问 http://你的IP:$vertex_port 使用"
    return 0
}

# Autoremove-torrents安装函数
install_autoremove_torrents() {
    need_input "请输入用户名："
    read username
    
    need_input "请输入密码："
    read -s password
    
    if [[ -z "$username" ]] || [ -z "$password" ]; then
        fail "用户名或密码未设置"
        return 1
    fi
    
    need_input "请输入qBittorrent Web UI端口号 [8080]："
    read qb_port
    qb_port=${qb_port:-8080}
    
    if [ -f /home/$username/.config.yml ]; then
        fail "Autoremove-torrents已安装"
        return 1
    fi
    
    info "正在安装Autoremove-torrents..."
    
    ## Install Autoremove-torrents
    if [ -z $(which pipx) ]; then
        apt-get install pipx -y
        #Check if install is successful
        if [ $? -ne 0 ]; then
            fail "Pipx安装失败"
            #Alternative method
            apt-get -qqy install python3-distutils python3-apt
            [[ $(pip --version) ]] || (apt-get -qqy install curl && curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py && python3 get-pip.py && rm get-pip.py )
            pip -q install autoremove-torrents
            # Check if installation fail
            if [ $? -ne 0 ]; then
                fail "Autoremove-torrents安装失败"
                return 1
            fi
        else
            su $username -s /bin/sh -c "pipx install autoremove-torrents"
            # Check if installation fail
            if [ $? -ne 0 ]; then
                fail "Autoremove-torrents安装失败"
                return 1
            fi
            su $username -s /bin/sh -c "pipx ensurepath"
        fi
    fi
    
    # qBittorrent配置
    if test -f /usr/bin/qbittorrent-nox; then
        touch /home/$username/.config.yml && chown $username:$username /home/$username/.config.yml
        cat << EOF >>/home/$username/.config.yml
General-qb:          
  client: qbittorrent
  host: http://127.0.0.1:$qb_port
  username: $username
  password: $password
  strategies:
    General:
      seeding_time: 3153600000
  delete_data: true
EOF
    else
        warn "未检测到qBittorrent，请先安装qBittorrent"
    fi
    
    sed -i 's+127.0.0.1: +127.0.0.1:+g' /home/$username/.config.yml
    mkdir -p /home/$username/.autoremove-torrents/log && chown -R $username /home/$username/.autoremove-torrents
    touch /home/$username/.autoremove-torrents/autoremove-torrents.sh && chown $username:$username /home/$username/.autoremove-torrents/autoremove-torrents.sh
    cat << EOF >/home/$username/.autoremove-torrents/autoremove-torrents.sh
#!/bin/bash
while true; do
    /home/$username/.local/bin/autoremove-torrents --conf=/home/$username/.config.yml --log=/home/$username/.autoremove-torrents/log
    sleep 5s
done
EOF
    chmod +x /home/$username/.autoremove-torrents/autoremove-torrents.sh
    
    # 创建Autoremove-torrents服务
    touch /etc/systemd/system/autoremove-torrents@.service
    cat << EOF >/etc/systemd/system/autoremove-torrents@.service
[Unit]
Description=autoremove-torrents service
After=syslog.target network-online.target

[Service]
Type=simple
User=$username
Group=$username
ExecStart=/home/$username/.autoremove-torrents/autoremove-torrents.sh

[Install]
WantedBy=multi-user.target
EOF
    
    # 启用并启动Autoremove-torrents
    systemctl enable autoremove-torrents@$username
    systemctl start autoremove-torrents@$username
    
    info "Autoremove-torrents安装完成，将根据配置自动删除种子"
    return 0
}

# qBittorrent安装模块
## qBittorrent版本列表
declare -a qb_ver_list=("4.1.9" "4.1.9.1" "4.3.8" "4.3.9" "4.6.7" "5.0.3" "5.0.4")
# 生成qBittorrent版本名称列表
unset qb_name_list i
for i in "${qb_ver_list[@]}"
do
    qb_name_list+=("qBittorrent-$i")
done

## libtorrent版本列表
declare -a lib_ver_list=("1_1_14" "v1.2.14" "v1.2.19" "v1.2.20" "v2.0.11")
# 生成libtorrent版本名称列表
unset lib_name_list i
for i in "${lib_ver_list[@]}"
do
    lib_name_list+=("libtorrent-$i")
done

# 选择qBittorrent版本
qb_ver_choose() {
    need_input "请选择qBittorrent版本:"
    select opt in "${qb_name_list[@]}"
    do
        case $opt in
        qBittorrent*)
            qb_ver=${opt}; break
            ;;
        *) warn "请选择有效版本" ;;
        esac
    done
}

# 选择libtorrent版本
lib_ver_choose() {
    ## 检查qb_ver是否为空
    if [[ -z "$qb_ver" ]]; then
        qb_ver_choose
    fi

    ## 让用户选择与qBittorrent配套的libtorrent版本
    need_input "请选择libtorrent版本:"
    select opt in "${lib_name_list[@]}"
    do
        case $opt in
        libtorrent*)
            lib_ver=${opt}; break
            ;;
        *) warn "请选择有效版本" ;;
        esac
    done
}

# 检查libtorrent版本兼容性
lib_ver_check() {
    ## 检查lib_ver是否为空
    if [[ -z "$lib_ver" ]]; then
        lib_ver_choose
    fi
    
    ## 检查libtorrent版本是否受支持
    if [[ ! " ${lib_name_list[@]} " =~ " ${lib_ver} " ]]; then
        warn "libtorrent $lib_ver 不受支持"
        lib_ver_choose
    fi
    
    ## 检查libtorrent版本是否与qBittorrent版本兼容
    if [[ "${qb_ver}" =~ "4.1." ]]; then
        while true
        do
            if [[ ! "${lib_ver}" == "libtorrent-1_1_14" ]]; then
                tput sgr0; clear
                warn "qBittorrent $qb_ver 与 libtorrent $lib_ver 不兼容"
                warn "qBittorrent $qb_ver 仅兼容 libtorrent-1_1_x"
                warn "请选择兼容版本"
                lib_ver_choose
            else
                break
            fi
        done
    elif [[ "${qb_ver}" =~ "4.2." ]]; then
        while true
        do
            if [[ ! "${lib_ver}" =~ "libtorrent-v1.2." ]]; then
                tput sgr0; clear
                warn "qBittorrent $qb_ver 与 libtorrent $lib_ver 不兼容"
                warn "qBittorrent $qb_ver 仅兼容 libtorrent-v1.2.x"
                warn "请选择兼容版本"
                lib_ver_choose
            else
                break
            fi
        done
    elif [[ "${qb_ver}" =~ "4.3." ]]; then
        while true
        do
            if [[ ! "${lib_ver}" =~ "libtorrent-v1.2." ]]; then
                tput sgr0; clear
                warn "qBittorrent $qb_ver 与 libtorrent $lib_ver 不兼容"
                warn "qBittorrent $qb_ver 仅兼容 libtorrent-v1.2.x"
                warn "请选择兼容版本"
                lib_ver_choose
            else
                break
            fi
        done
    elif [[ "${qb_ver}" =~ "4.4." ]]; then
        while true
        do
            if [[ ! "${lib_ver}" =~ "libtorrent-v1.2." ]] && [[ ! "${lib_ver}" =~ "libtorrent-v2.0." ]]; then
                tput sgr0; clear
                warn "qBittorrent $qb_ver 与 libtorrent $lib_ver 不兼容"
                warn "qBittorrent $qb_ver 仅兼容 libtorrent-v1.2.x 或 libtorrent-v2.0.x"
                warn "请选择兼容版本"
                lib_ver_choose
            else
                break
            fi
        done
    elif [[ "${qb_ver}" =~ "4.5." ]]; then
        while true
        do
            if [[ ! "${lib_ver}" =~ "libtorrent-v1.2." ]] && [[ ! "${lib_ver}" =~ "libtorrent-v2.0." ]]; then
                tput sgr0; clear
                warn "qBittorrent $qb_ver 与 libtorrent $lib_ver 不兼容"
                warn "qBittorrent $qb_ver 仅兼容 libtorrent-v1.2.x 或 libtorrent-v2.0.x"
                warn "请选择兼容版本"
                lib_ver_choose
            else
                break
            fi
        done
    elif [[ "${qb_ver}" =~ "4.6." ]]; then
        while true
        do
            if [[ ! "${lib_ver}" =~ "libtorrent-v1.2." ]] && [[ ! "${lib_ver}" =~ "libtorrent-v2.0." ]]; then
                tput sgr0; clear
                warn "qBittorrent $qb_ver 与 libtorrent $lib_ver 不兼容"
                warn "qBittorrent $qb_ver 仅兼容 libtorrent-v1.2.x 或 libtorrent-v2.0.x"
                warn "请选择兼容版本"
                lib_ver_choose
            else
                break
            fi
        done
    elif [[ "${qb_ver}" =~ "5.0." ]]; then
        while true
        do
            if [[ ! "${lib_ver}" =~ "libtorrent-v1.2." ]] && [[ ! "${lib_ver}" =~ "libtorrent-v2.0." ]]; then
                tput sgr0; clear
                warn "qBittorrent $qb_ver 与 libtorrent $lib_ver 不兼容"
                warn "qBittorrent $qb_ver 仅兼容 libtorrent-v1.2.x 或 libtorrent-v2.0.x"
                warn "请选择兼容版本"
                lib_ver_choose
            else
                break
            fi
        done
    fi
}

# 检查qBittorrent安装参数
qb_install_check() {
    # 检查qBittorrent版本和libtorrent版本是否受支持
    ## 检查qBittorrent版本是否受支持
    if [[ ! " ${qb_name_list[@]} " =~ " ${qb_ver} " ]]; then
        warn "qBittorrent $qb_ver 不受支持"
        qb_ver_choose
    fi
    ## 检查libtorrent版本是否受支持
    if [[ ! " ${lib_name_list[@]} " =~ " ${lib_ver} " ]]; then
        warn "libtorrent $lib_ver 不受支持"
        lib_ver_check
    fi
    ## 检查libtorrent版本是否与qBittorrent版本兼容
    lib_ver_check
}

# 安装qBittorrent
install_qbittorrent() {
    # 获取用户输入
    need_input "请输入用户名："
    read username
    
    if [[ -z "$username" ]]; then
        fail "未设置用户名"
        return 1
    fi
    
    if [ -z "$(getent passwd $username)" ]; then
        need_input "用户不存在，是否创建用户？(y/n)"
        read create_user
        if [[ "$create_user" == "y" || "$create_user" == "Y" ]]; then
            adduser --gecos "" $username
        else
            fail "用户不存在"
            return 1
        fi
    fi
    
    need_input "请输入密码："
    read -s password
    echo ""
    
    if [[ -z "$password" ]]; then
        fail "未设置密码"
        return 1
    fi
    
    # 选择qBittorrent和libtorrent版本
    qb_ver_choose
    lib_ver_choose
    qb_install_check
    
    # 设置qBittorrent参数
    need_input "请输入磁盘缓存大小(MB) [64]："
    read qb_cache
    qb_cache=${qb_cache:-64}
    
    need_input "请输入Web UI端口 [8080]："
    read qb_port
    qb_port=${qb_port:-8080}
    
    need_input "请输入传入连接端口 [6881]："
    read qb_incoming_port
    qb_incoming_port=${qb_incoming_port:-6881}
    
    info "开始安装qBittorrent..."
    
    # 调用安装函数
    install_qBittorrent_ "$username" "$password" "$qb_ver" "$lib_ver" "$qb_cache" "$qb_port" "$qb_incoming_port"
    
    if [ $? -eq 0 ]; then
        info "qBittorrent安装成功，访问 http://你的IP:$qb_port 使用"
    else
        fail "qBittorrent安装失败"
    fi
    
    return 0
}

# qBittorrent安装函数
install_qBittorrent_() {
    username=$1
    password=$2
    qb_ver=$3
    lib_ver=$4
    qb_cache=$5
    qb_port=$6
    qb_incoming_port=$7

    ## 检查qBittorrent是否正在运行
    if pgrep -i -f qbittorrent; then
        warn "qBittorrent正在运行，正在停止..."
        pkill -s $(pgrep -i -f qbittorrent)
    fi
    # 检查是否仍在运行
    if pgrep -i -f qbittorrent; then
        warn "无法停止qBittorrent，请手动停止"
        return 1
    fi

    ## 检查qbittorrent-nox是否已安装
    if test -e /usr/bin/qbittorrent-nox; then
        warn "qBittorrent已安装，正在替换..."
        rm /usr/bin/qbittorrent-nox
    fi

    ## 下载qBittorrent-nox可执行文件
    # 确定CPU架构
    if [[ $(uname -m) == "x86_64" ]]; then
        arch="x86_64"
    elif [[ $(uname -m) == "aarch64" ]]; then
        arch="ARM64"
    else
        warn "不支持的CPU架构"
        return 1
    fi
    
    info "下载qBittorrent-nox可执行文件..."
    wget https://raw.githubusercontent.com/guowanghushifu/Seedbox-Components/main/Torrent%20Clients/qBittorrent/$arch/$qb_ver%20-%20$lib_ver/qbittorrent-nox -O $HOME/qbittorrent-nox && chmod +x $HOME/qbittorrent-nox
    # 检查下载是否成功
    if [ $? -ne 0 ]; then
        warn "无法下载qBittorrent-nox可执行文件"
        return 1
    fi

    # 安装qbittorrent-nox
    info "安装qBittorrent-nox..."
    mv $HOME/qbittorrent-nox /usr/bin/qbittorrent-nox
    mkdir -p /home/$username/qbittorrent/Downloads && chown -R $username:$username /home/$username/qbittorrent/
    mkdir -p /home/$username/.config/qBittorrent && chown $username:$username /home/$username/.config/qBittorrent

    # 创建systemd服务
    info "创建systemd服务..."
    if test -e /etc/systemd/system/qbittorrent-nox@.service; then
        warn "qBittorrent systemd服务已存在，正在移除..."
        rm /etc/systemd/system/qbittorrent-nox@.service
    fi
    touch /etc/systemd/system/qbittorrent-nox@.service
    cat << EOF >/etc/systemd/system/qbittorrent-nox@.service
[Unit]
Description=qBittorrent
After=network.target

[Service]
Type=forking
User=$username
LimitNOFILE=infinity
ExecStart=/usr/bin/qbittorrent-nox -d
ExecStop=/usr/bin/killall -w -s 9 /usr/bin/qbittorrent-nox
Restart=on-failure
TimeoutStopSec=20
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF
    systemctl enable qbittorrent-nox@$username
    systemctl start qbittorrent-nox@$username

    ## 配置qBittorrent
    info "优化qBittorrent配置..."
    # 检查虚拟环境，因为某些优化可能在虚拟机上不起作用
    systemd-detect-virt > /dev/null
    if [ $? -eq 0 ]; then
        warn "检测到虚拟化环境，跳过部分优化"
        aio=8
        low_buffer=3072
        buffer=12288
        buffer_factor=200
    else
        # 确定是SSD还是HDD
        disk_name=$(printf $(lsblk | grep -m1 'disk' | awk '{print $1}'))
        disktype=$(cat /sys/block/$disk_name/queue/rotational)
        if [ "${disktype}" == 0 ]; then
            aio=8
            low_buffer=5120
            buffer=20480
            buffer_factor=200
        else
            aio=4
            low_buffer=3072
            buffer=10240
            buffer_factor=150
        fi
    fi

    # 编辑qBittorrent设置
    info "应用qBittorrent设置..."
    systemctl stop qbittorrent-nox@$username

    if [[ "${qb_ver}" =~ "4.1." ]]; then
        md5password=$(echo -n $password | md5sum | awk '{print $1}')
        cat << EOF >/home/$username/.config/qBittorrent/qBittorrent.conf
[BitTorrent]
Session\AsyncIOThreadsCount=$aio
Session\SendBufferLowWatermark=$low_buffer
Session\SendBufferWatermark=$buffer
Session\SendBufferWatermarkFactor=$buffer_factor

[LegalNotice]
Accepted=true

[Network]
Cookies=@Invalid()

[Preferences]
Connection\PortRangeMin=$qb_incoming_port
Downloads\DiskWriteCacheSize=$qb_cache
Downloads\SavePath=/home/$username/qbittorrent/Downloads/
Queueing\QueueingEnabled=false
WebUI\Password_ha1=@ByteArray($md5password)
WebUI\Port=$qb_port
WebUI\Username=$username
EOF
    elif [[ "${qb_ver}" =~ "4.2."|"4.3." ]]; then
        info "下载密码生成工具..."
        wget https://raw.githubusercontent.com/guowanghushifu/Seedbox-Components/main/Torrent%20Clients/qBittorrent/$arch/qb_password_gen -O $HOME/qb_password_gen && chmod +x $HOME/qb_password_gen
        # 检查下载是否成功
        if [ $? -ne 0 ]; then
            warn "无法下载qb_password_gen"
            # 清理
            rm -r /home/$username/qbittorrent/Downloads
            rm -r /home/$username/.config/qBittorrent
            rm /usr/bin/qbittorrent-nox
            rm /etc/systemd/system/qbittorrent-nox@.service
            return 1
        fi
        PBKDF2password=$($HOME/qb_password_gen $password)
        cat << EOF >/home/$username/.config/qBittorrent/qBittorrent.conf
[BitTorrent]
Session\AsyncIOThreadsCount=$aio
Session\SendBufferLowWatermark=$low_buffer
Session\SendBufferWatermark=$buffer
Session\SendBufferWatermarkFactor=$buffer_factor

[LegalNotice]
Accepted=true

[Network]
Cookies=@Invalid()

[Preferences]
Connection\PortRangeMin=$qb_incoming_port
Downloads\DiskWriteCacheSize=$qb_cache
Downloads\SavePath=/home/$username/qbittorrent/Downloads/
Queueing\QueueingEnabled=false
WebUI\Password_PBKDF2="@ByteArray($PBKDF2password)"
WebUI\Port=$qb_port
WebUI\Username=$username
EOF
        rm $HOME/qb_password_gen
    elif [[ "${qb_ver}" =~ "4.4."|"4.5."|"4.6."|"5.0." ]]; then
        info "下载密码生成工具..."
        wget https://raw.githubusercontent.com/guowanghushifu/Seedbox-Components/main/Torrent%20Clients/qBittorrent/$arch/qb_password_gen -O $HOME/qb_password_gen && chmod +x $HOME/qb_password_gen
        # 检查下载是否成功
        if [ $? -ne 0 ]; then
            warn "无法下载qb_password_gen"
            # 清理
            rm -r /home/$username/qbittorrent/Downloads
            rm -r /home/$username/.config/qBittorrent
            rm /usr/bin/qbittorrent-nox
            rm /etc/systemd/system/qbittorrent-nox@.service
            return 1
        fi
        PBKDF2password=$($HOME/qb_password_gen $password)
        cat << EOF >/home/$username/.config/qBittorrent/qBittorrent.conf
[Application]
MemoryWorkingSetLimit=$qb_cache

[BitTorrent]
Session\AsyncIOThreadsCount=$aio
Session\DefaultSavePath=/home/$username/qbittorrent/Downloads/
Session\DiskCacheSize=$qb_cache
Session\Port=$qb_incoming_port
Session\QueueingSystemEnabled=false
Session\SendBufferLowWatermark=$low_buffer
Session\SendBufferWatermark=$buffer
Session\SendBufferWatermarkFactor=$buffer_factor

[LegalNotice]
Accepted=true

[Network]
Cookies=@Invalid()

[Preferences]
WebUI\Password_PBKDF2="@ByteArray($PBKDF2password)"
WebUI\Port=$qb_port
WebUI\Username=$username
EOF
        rm $HOME/qb_password_gen
    fi
    
    systemctl start qbittorrent-nox@$username
    
    # 检查qBittorrent是否成功启动
    sleep 5
    if ! pgrep -i -f qbittorrent; then
        warn "qBittorrent启动失败"
        return 1
    fi
    
    return 0
} 


# 系统优化模块
# 内核参数优化
kernel_settings() {
    info "配置内核参数..."
    # 检测内存大小
    memory_size=$(grep MemTotal /proc/meminfo | awk '{print $2}')
    # 定义TCP内存上限
    tcp_mem_min_cap=262144 #1GB
    tcp_mem_pressure_cap=2097152 #8GB
    tcp_mem_max_cap=4194304 #16GB

    if [ -n "$memory_size" ]; then
        # 内存大小（以4K页为单位）
        memory_4k=$(( $memory_size / 4 ))
        # 计算TCP内存值
        if [ $memory_size -le 524288 ]; then        # 如果内存等于或小于512MB
            tcp_mem_min=$(( $memory_4k / 32 )) && tcp_mem_pressure=$(( $memory_4k / 16 )) && tcp_mem_max=$(( $memory_4k / 8 ))
            rmem_max=8388608 && wmem_max=8388608 && win_scale=3
        elif [ $memory_size -le 1048576 ]; then     # 如果内存等于或小于1GB
            tcp_mem_min=$(( $memory_4k / 16 )) && tcp_mem_pressure=$(( $memory_4k / 8 )) && tcp_mem_max=$(( $memory_4k / 6 ))
            rmem_max=16777216 && wmem_max=16777216 && win_scale=2
        elif [ $memory_size -le 4194304 ]; then     # 如果内存等于或小于4GB
            tcp_mem_min=$(( $memory_4k / 8 )) && tcp_mem_pressure=$(( $memory_4k / 6 )) && tcp_mem_max=$(( $memory_4k / 4 ))
            rmem_max=33554432 && wmem_max=33554432 && win_scale=2
        elif [ $memory_size -le 16777216 ]; then    # 如果内存等于或小于16GB
            tcp_mem_min=$(( $memory_4k / 8 )) && tcp_mem_pressure=$(( $memory_4k / 4 )) && tcp_mem_max=$(( $memory_4k / 2 ))
            rmem_max=67108864 && wmem_max=67108864 && win_scale=1
        else                                        # 如果内存大于16GB
            tcp_mem_min=$(( $memory_4k / 8 )) && tcp_mem_pressure=$(( $memory_4k / 4 )) && tcp_mem_max=$(( $memory_4k / 2 ))
            rmem_max=134217728 && wmem_max=134217728 && win_scale=-2
        fi
        
        # 检查计算的值是否大于上限
        if [ $tcp_mem_min -gt $tcp_mem_min_cap ]; then
            tcp_mem_min=$tcp_mem_min_cap
        fi
        if [ $tcp_mem_pressure -gt $tcp_mem_pressure_cap ]; then
            tcp_mem_pressure=$tcp_mem_pressure_cap
        fi
        if [ $tcp_mem_max -gt $tcp_mem_max_cap ]; then
            tcp_mem_max=$tcp_mem_max_cap
        fi
        tcp_mem="$tcp_mem_min $tcp_mem_pressure $tcp_mem_max"
    else
        fail "找不到内存大小"
        tcp_mem=$(cat /proc/sys/net/ipv4/tcp_mem)
        tcp_rmem=$(cat /proc/sys/net/ipv4/tcp_rmem)
        tcp_wmem=$(cat /proc/sys/net/ipv4/tcp_wmem)
        rmem_max=$(cat /proc/sys/net/core/rmem_max)
        wmem_max=$(cat /proc/sys/net/core/wmem_max)
        win_scale=$(cat /proc/sys/net/ipv4/tcp_adv_win_scale)
    fi
    
    # 设置值
    rmem_default=262144 && wmem_default=16384
    tcp_rmem="8192 $rmem_default $rmem_max" && tcp_wmem="4096 $wmem_default $wmem_max"
    
    # 检查所有变量是否已设置
    if [[ -z $tcp_mem ]] || [[ -z $tcp_rmem ]] || [[ -z $tcp_wmem ]] || [ -z $rmem_max ] || [ -z $wmem_max ] || [ -z $win_scale ]; then
        fail "内核设置未设置"
        return 1
    fi
    
    info "备份原始sysctl.conf"
    cp /etc/sysctl.conf /etc/sysctl.conf.backup

    cat > /etc/sysctl.d/99-seedbox.conf << EOF
###/proc/sys/kernel/ Variables:
##https://www.kernel.org/doc/Documentation/admin-guide/sysctl/kernel.rst

# Allow for more PIDs
kernel.pid_max = 4194303

# Maximum size of an IPC queue
kernel.msgmnb = 65536

# maximum size of an IPC message
kernel.msgmax = 65536

## Process Scheduler Optimization
kernel.sched_migration_cost_ns = 5000000
kernel.sched_autogroup_enabled = 0
kernel.sched_min_granularity_ns = 10000000
kernel.sched_wakeup_granularity_ns = 15000000





###/proc/sys/fs/
##https://www.kernel.org/doc/Documentation/admin-guide/sysctl/fs.rst

# Maximum number of file-handles that the Linux kernel will allocate
fs.file-max = 1048576

# Maximum number of file-handles a process can allocate
fs.nr_open = 1048576





###/proc/sys/vm Variables:
##https://www.kernel.org/doc/Documentation/admin-guide/sysctl/vm.rst

# Percentage of available system memory which when dirty then system can start writing data to the disks
# NOTE: The total available memory is not equal to total system memory
vm.dirty_background_ratio = 5
# Percentage of available system memory which when dirty, the process doing writes would block and write out dirty pages to the disks
vm.dirty_ratio = 30

# Define when dirty inode is old enough to be eligible for writeback by the kernel flusher threads & interval to wakeup dirtytime_writeback thread
vm.dirty_expire_centisecs = 1000
# Period between each wake up and write old data out to disk
vm.dirty_writeback_centisecs = 100

# Reduce swapping and keep memory pages in physical memory
vm.swappiness = 10





###/proc/sys/net/core - Network core options:
##https://www.kernel.org/doc/Documentation/admin-guide/sysctl/net.rst


# NOTE: Difference in polling and interrupt
#		-Interrupt: Interrupt is a hardware mechanism in which, the device notices the CPU that it requires its attention./
#			Interrupt can take place at any time. So when CPU gets an interrupt signal trough the indication interrupt-request line,/
#			CPU stops the current process and respond to the interrupt by passing the control to interrupt handler which services device.
#	    -Polling: In polling is not a hardware mechanism, its a protocol in which CPU steadily checks whether the device needs attention./
#			Wherever device tells process unit that it desires hardware processing, #in polling process unit keeps asking the I/O device whether or not it desires CPU processing./
#			The CPU ceaselessly check every and each device hooked up thereto for sleuthing whether or not any device desires hardware attention.
#	    The Linux kernel uses the interrupt-driven mode by default and only switches to polling mode when the flow of incoming packets exceeds "net.core.dev_weight" number of data frames
# The maximum number of packets that kernel can handle on a NAPI interrupt, it's a Per-CPU variable
#net.core.dev_weight = 64
# Scales the maximum number of packets that can be processed during a RX softirq cycle. Calculation is based on dev_weight (dev_weight * dev_weight_rx_bias)
#net.core.dev_weight_rx_bias = 1
# Scales the maximum number of packets that can be processed during a TX softirq cycle. Calculation is based on dev_weight (dev_weight * dev_weight_tx_bias)
#net.core.dev_weight_tx_bias = 1

# NOTE: If the second column of "cat /proc/net/softnet_stat" is huge, there are frame drops and it might be wise to increase the value of net.core.netdev_max_backlog/
#If the third column increases, there are SoftIRQ Misses and it might be wise to increase either or both net.core.netdev_budget and net.core.netdev_budget_usecs
# Maximum number of packets taken from all interfaces in one polling cycle (NAPI poll).
net.core.netdev_budget = 50000
# Maximum number of microseconds in one polling cycle (NAPI poll).
# NOTE: Could reduce if you have a CPU with high single core performance, NIC that supports RSS
# NOTE: Setting a high number might cause CPU to stall and end in poor overall performance
net.core.netdev_budget_usecs = 8000
# Maximum number  of  packets,  queued  on  the  INPUT  side, when the interface receives packets faster than kernel can process them
net.core.netdev_max_backlog = 100000

# Low latency busy poll timeout for socket reads
# NOTE: Not supported by most NIC
#net.core.busy_read=50
# Low latency busy poll timeout for poll and select
# NOTE: Not supported by most NIC
#net.core.busy_poll=50


# Receive socket buffer size
net.core.rmem_default = $rmem_default
net.core.rmem_max = $rmem_max

# Send socket buffer size
net.core.wmem_default = $wmem_default 
net.core.wmem_max = $wmem_max

# Maximum ancillary buffer size allowed per socket
# NOTE:Setting this value too high can lead to excessive kernel memory allocation for sockets, which might not be needed and could potentially waste system resources. 
net.core.optmem_max = 4194304





###/proc/sys/net/ipv4/* Variables:
##https://www.kernel.org/doc/Documentation/networking/ip-sysctl.rst
## Routing Settings
# Time, in seconds, that cached PMTU information is kept
net.ipv4.route.mtu_expires = 1800
# Lowest possible mss setting, actuall advertised MSS depends on the first hop route MTU
net.ipv4.route.min_adv_mss = 536
# Set PMTU to this value if fragmentation-required ICMP is received for that destination
# NOTE: Only necessary if "net.ipv4.ip_no_pmtu_disc" is set to mode 1
#net.ipv4.route.min_pmtu = 1500





## IP
# System IP port limits
net.ipv4.ip_local_port_range = 1024 65535

# Allow Path MTU Discovery
net.ipv4.ip_no_pmtu_disc = 0




## ARP table settings
# The maximum number of bytes which may be used by packets queued for each unresolved address by other network layers
net.ipv4.neigh.default.unres_qlen_bytes = 16777216

# The maximum number of packets which may be queued for each unresolved address by other network layers
# NOTE: Deprecated in Linux 3.3 : use unres_qlen_bytes instead
#net.ipv4.neigh.default.unres_qlen = 1024




## TCP variables
# Maximum queue length of completely established sockets waiting to be accepted
net.core.somaxconn = 524288

#Maximum queue length of incomplete sockets i.e. half-open connection
#NOTE: THis value should not be above "net.core.somaxconn", since that is also a hard open limit of maximum queue length of incomplete sockets/
#Kernel will take the lower one out of two as the maximum queue length of incomplete sockets
net.ipv4.tcp_max_syn_backlog = 524288

# Recover and handle all requests instead of resetting them when system is overflowed with a burst of new connection attempts
net.ipv4.tcp_abort_on_overflow = 0

# Maximal number of TCP sockets not attached to any user file handle (i.e. orphaned connections), held by system.
# NOTE: each orphan eats up to ~64K of unswappable memory
net.ipv4.tcp_max_orphans = 262144

# Maximal number of time-wait sockets held by system simultaneously
net.ipv4.tcp_max_tw_buckets = 10240


# Enable TCP Packetization-Layer Path, and use initial MSS of tcp_base_mss
net.ipv4.tcp_mtu_probing = 2

# Starting MSS used in Path MTU discovery
net.ipv4.tcp_base_mss = 1460

#  Minimum MSS used in connection, cap it to this value even if advertised ADVMSS option is even lower
net.ipv4.tcp_min_snd_mss = 536


# Enable selective acknowledgments 
net.ipv4.tcp_sack = 1
# Send SACK more frequently
net.ipv4.tcp_comp_sack_delay_ns = 250000

# Allows TCP to send "duplicate" SACKs
net.ipv4.tcp_dsack = 1

# Enable Early Retransmit. ER lowers the threshold for triggering fast retransmit when the amount of outstanding data is small and when no previously unsent data can be transmitted
net.ipv4.tcp_early_retrans = 3

# Disable ECN
net.ipv4.tcp_ecn = 0

# Enable Forward Acknowledgment
# NOTE: This is a legacy option, it has no effect anymore
# net.ipv4.tcp_fack = 1


# TCP buffer size
# Values are measured in memory pages. Size of memory pages can be found by "getconf PAGESIZE". Normally it is 4096 bytes
# Vector of 3 INTEGERs: min, pressure, max
#	min: below this number of pages TCP is not bothered about its
#	memory appetite.
#
#	pressure: when amount of memory allocated by TCP exceeds this number
#	of pages, TCP moderates its memory consumption and enters memory
#	pressure mode, which is exited when memory consumption falls
#	under "min".
#
#	max: number of pages allowed for queuing by all TCP sockets
net.ipv4.tcp_mem = $tcp_mem

# TCP sockets receive buffer
# Vector of 3 INTEGERs: min, default, max
#	min: Minimal size of receive buffer used by TCP sockets.
#	It is guaranteed to each TCP socket, even under moderate memory
#	pressure.
#
#	default: initial size of receive buffer used by TCP sockets.
#	This value overrides net.core.rmem_default used by other protocols.
#
#	max: maximal size of receive buffer allowed for automatically
#	selected receiver buffers for TCP socket. This value does not override
#	net.core.rmem_max.  Calling setsockopt() with SO_RCVBUF disables
#	automatic tuning of that socket's receive buffer size, in which
#	case this value is ignored.
net.ipv4.tcp_rmem = $tcp_rmem

# Enable receive buffer auto-tuning
net.ipv4.tcp_moderate_rcvbuf = 1

# Distribution of socket receive buffer space between TCP window size(this is the size of the receive window advertised to the other end), and application buffer/
#The overhead (application buffer) is counted as bytes/2^tcp_adv_win_scale i.e. Setting this 2 would mean we use 1/4 of socket buffer space as overhead
# NOTE: Overhead reduces the effective window size, which in turn reduces the maximum possible data in flight which is window size*RTT
# NOTE: Overhead helps isolating the network from scheduling and application latencies
net.ipv4.tcp_adv_win_scale = $win_scale

# Max reserved byte of TCP window for application buffer. The value will be between window/2^tcp_app_win and mss
# See "https://www.programmersought.com/article/75001203063/" for more detail about tcp_app_win & tcp_adv_win_scale
# NOTE: This application buffer is different from the one assigned by tcp_adv_win_scale
# Default
# net.ipv4.tcp_app_win = 31

# TCP sockets send buffer
# Vector of 3 INTEGERs: min, default, max
#	min: Amount of memory reserved for send buffers for TCP sockets.
#	Each TCP socket has rights to use it due to fact of its birth.
#
#	default: initial size of send buffer used by TCP sockets.  This
#	value overrides net.core.wmem_default used by other protocols.
#	It is usually lower than net.core.wmem_default.
#
#	max: Maximal amount of memory allowed for automatically tuned
#	send buffers for TCP sockets. This value does not override
#	net.core.wmem_max.  Calling setsockopt() with SO_SNDBUF disables
#	automatic tuning of that socket's send buffer size, in which case
#	this value is ignored.
net.ipv4.tcp_wmem = $tcp_wmem


# Reordering level of packets in a TCP stream
# NOTE: Reordering is costly but it happens quite a lot. Instead of declaring packet lost and requiring retransmit, try harder to reorder first
# Initial reordering level of packets in a TCP stream. TCP stack can then dynamically adjust flow reordering level between this initial value and tcp_max_reordering
net.ipv4.tcp_reordering = 10
# Maximal reordering level of packets in a TCP stream
net.ipv4.tcp_max_reordering = 600


# Number of times SYNACKs for a passive TCP connection attempt will be retransmitted
net.ipv4.tcp_synack_retries = 10
# Number of times initial SYNs for an active TCP connection attempt	will be retransmitted
net.ipv4.tcp_syn_retries = 7

# In seconds, time default value for connections to keep alive
net.ipv4.tcp_keepalive_time = 7200
# How many keepalive probes TCP sends out, until it decides that the connection is broken
net.ipv4.tcp_keepalive_probes = 15
# In seconds, how frequently the probes are send out
net.ipv4.tcp_keepalive_intvl = 60

# Number of retries before killing a TCP connection
# Time, after which TCP decides, that something is wrong due to unacknowledged RTO retransmissions,	and reports this suspicion to the network layer.
net.ipv4.tcp_retries1 = 3
# Time, after which TCP decides to timeout the TCP connection, when RTO retransmissions remain unacknowledged
net.ipv4.tcp_retries2 = 10

# How many times to retry to kill connections on the other side before killing it on our own side
net.ipv4.tcp_orphan_retries = 2

#Disable TCP auto corking, as it needlessly increasing latency when the application doesn't expect to send more data
net.ipv4.tcp_autocorking = 0

# Disables Forward RTO-Recovery, since we are not operating on a lossy wireless network
net.ipv4.tcp_frto = 0

# Protect Against TCP TIME-WAIT Assassination
net.ipv4.tcp_rfc1337 = 1

# Avoid falling back to slow start after a connection goes idle
net.ipv4.tcp_slow_start_after_idle = 0

# Enable both client support & server support of TCP Fast Open
net.ipv4.tcp_fastopen = 3

# Disable timestamps
net.ipv4.tcp_timestamps = 0

# Keep sockets in the state FIN-WAIT-2 for ultra short period if we were the one closing the socket, because this gives us no benefit and eats up memory
net.ipv4.tcp_fin_timeout = 5

# Enable cache metrics on closing connections
net.ipv4.tcp_no_metrics_save = 1

# Enable reuse of TIME-WAIT sockets for new connections
net.ipv4.tcp_tw_reuse = 1


# Allows the use of a large window (> 64 kB) on a TCP connection
net.ipv4.tcp_window_scaling = 1

# Set maximum window size to MAX_TCP_WINDOW i.e. 32767 in times there is no received window scaling option
net.ipv4.tcp_workaround_signed_windows = 1


# The maximum amount of unsent bytes in TCP socket write queue, this is on top of the congestion window
net.ipv4.tcp_notsent_lowat = 131072

# Controls the amount of data in the Qdisc queue or device queue
net.ipv4.tcp_limit_output_bytes = 3276800

# Controls a per TCP socket cache of one socket buffer
# Use Huge amount of memory
#net.ipv4.tcp_rx_skb_cache = 1

# Congestion Control
net.core.default_qdisc = fq
net.ipv4.tcp_congestion_control = bbr
EOF

    info "应用内核参数..."
    sysctl -p /etc/sysctl.d/99-seedbox.conf
    
    info "内核参数优化完成"
    return 0
}

# 文件打开限制配置
set_file_open_limit() {
    need_input "请输入用户名："
    read username
    
    if [[ -z "$username" ]]; then
        fail "未设置用户名"
        return 1
    fi
    
    if [ -z "$(getent passwd $username)" ]; then
        need_input "用户不存在，是否创建用户？(y/n)"
        read create_user
        if [[ "$create_user" == "y" || "$create_user" == "Y" ]]; then
            adduser --gecos "" $username
        else
            fail "用户不存在"
            return 1
        fi
    fi
    
    info "设置文件打开限制..."
    
    if ! grep -q "$username.*nofile" /etc/security/limits.conf; then
        cat << EOF >> /etc/security/limits.conf
## Hard limit for max opened files
root        hard nofile 1048576
$username        hard nofile 1048576
## Soft limit for max opened files
$username        soft nofile 1048576
root        soft nofile 1048576
EOF
    else
        info "文件打开限制已经存在，跳过"
    fi
    
    info "文件打开限制设置完成"
    return 0
}

# 磁盘调度器设置
set_disk_scheduler() {
    info "设置磁盘调度器..."
    
    i=1
    drive=()
    # 列出所有可用驱动器
    disk=$(lsblk -nd --output NAME)
    # 检查磁盘是否设置
    if [[ -z "$disk" ]]; then
        fail "未找到磁盘"
        return 1
    fi
    
    # 计算驱动器数量
    diskno=$(echo $disk | wc -w)
    # 将设备名称放入数组，以便稍后遍历
    while [ $i -le $diskno ]
    do
        device=$(echo $disk | awk -v i=$i '{print $i}')
        drive+=($device)
        i=$(( $i + 1 ))
    done
    
    i=1 
    x=0
    # 根据磁盘是HDD还是SSD更改每个磁盘的调度器
    while [ $i -le $diskno ]
    do
        diskname=$(eval echo ${drive["$x"]})
        if [ -f /sys/block/$diskname/queue/rotational ]; then
            disktype=$(cat /sys/block/$diskname/queue/rotational)
            if [ "${disktype}" == 0 ]; then     
                echo kyber > /sys/block/$diskname/queue/scheduler 2>/dev/null || true
                info_2 "SSD $diskname 设置为 kyber 调度器"
            else
                echo mq-deadline > /sys/block/$diskname/queue/scheduler 2>/dev/null || true
                info_2 "HDD $diskname 设置为 mq-deadline 调度器"
            fi
        else
            warn "跳过 $diskname，无法确定类型"
        fi
        i=$(( $i + 1 )) 
        x=$(( $x + 1 ))
    done
    
    echo
    info "磁盘调度器设置完成"
    return 0
}

# Tuned
tuned() {
    info "安装并配置tuned..."
    if [ -z $(which tuned) ]; then
        apt-get -qqy install tuned
        #Check if install is successful
        if [ $? -ne 0 ]; then
            fail "Tuned安装失败"
            return 1
        fi
    fi
    
    # 启用tuned
    systemctl enable tuned
    systemctl start tuned
    
    # 显示可用的tuned配置文件
    info "可用的tuned配置文件:"
    tuned-adm list
    
    # 让用户选择一个配置文件
    need_input "请输入要使用的tuned配置文件(例如 throughput-performance):"
    read tuned_profile
    
    if [ -n "$tuned_profile" ]; then
        tuned-adm profile $tuned_profile
        info "已设置tuned配置文件: $tuned_profile"
    else
        tuned-adm profile throughput-performance
        info "已设置默认tuned配置文件: throughput-performance"
    fi
    
    info "tuned配置完成"
    return 0
} 


# 网络优化模块
# 网络优化综合函数
optimize_network() {
    info "优化网络设置..."
    
    # 获取主网络接口
    interface=$(ip -o -4 route show to default | awk '{print $5}' | head -n1)
    if [[ -z "$interface" ]]; then
        fail "无法检测到网络接口"
        return 1
    fi
    
    info "检测到网络接口: $interface"
    
    # 安装必要工具
    if [ -z "$(which ethtool)" ]; then
        info "安装ethtool..."
        apt-get -y install ethtool
        if [ $? -ne 0 ]; then
            fail "Ethtool安装失败"
            return 1
        fi
    fi
    
    if [ -z "$(which net-tools)" ]; then
        info "安装net-tools..."
        apt-get -y install net-tools
        if [ $? -ne 0 ]; then
            fail "net-tools安装失败"
            return 1
        fi
    fi
    
    # 设置Ring Buffer
    set_ring_buffer
    
    # 设置txqueuelen
    set_txqueuelen
    
    # 设置初始拥塞窗口
    set_initial_congestion_window
    
    # 禁用TSO
    disable_tso
    
    info "网络优化完成"
    return 0
}

# 设置Ring Buffer
set_ring_buffer() {
    info "设置Ring Buffer..."
    
    # 获取主网络接口
    interface=$(ip -o -4 route show to default | awk '{print $5}' | head -n1)
    if [[ -z "$interface" ]]; then
        fail "无法检测到网络接口"
        return 1
    fi
    
    if [ -z "$(which ethtool)" ]; then
        info "安装ethtool..."
        apt-get -y install ethtool
        if [ $? -ne 0 ]; then
            fail "Ethtool安装失败"
            return 1
        fi
    fi
    
    # 设置RX (接收) Ring Buffer
    ethtool -G $interface rx 1024 2>/dev/null
    if [ $? -ne 0 ]; then
        warn "Ring Buffer (RX) 设置失败"
    else
        info_2 "网络接口 $interface 的 RX Ring Buffer 设置为 1024"
    fi
    sleep 1
    
    # 设置TX (发送) Ring Buffer
    ethtool -G $interface tx 2048 2>/dev/null
    if [ $? -ne 0 ]; then
        warn "Ring Buffer (TX) 设置失败"
    else
        info_2 "网络接口 $interface 的 TX Ring Buffer 设置为 2048"
    fi
    sleep 1
    
    # 显示当前设置
    info "当前Ring Buffer设置:"
    ethtool -g $interface 2>/dev/null || warn "无法获取Ring Buffer信息"
    
    info "Ring Buffer设置完成"
    return 0
}

# 设置txqueuelen
set_txqueuelen() {
    info "设置txqueuelen..."
    
    # 获取主网络接口
    interface=$(ip -o -4 route show to default | awk '{print $5}' | head -n1)
    if [[ -z "$interface" ]]; then
        fail "无法检测到网络接口"
        return 1
    fi
    
    if [ -z "$(which net-tools)" ]; then
        info "安装net-tools..."
        apt-get -y install net-tools
        if [ $? -ne 0 ]; then
            fail "net-tools安装失败"
            return 1
        fi
    fi
    
    # 设置txqueuelen
    ifconfig $interface txqueuelen 10000
    if [ $? -ne 0 ]; then
        warn "txqueuelen设置失败"
    else
        info_2 "网络接口 $interface 的 txqueuelen 设置为 10000"
    fi
    sleep 1
    
    # 显示当前设置
    info "当前txqueuelen设置:"
    ifconfig $interface | grep txqueuelen || warn "无法获取txqueuelen信息"
    
    info "txqueuelen设置完成"
    return 0
}

# 设置初始拥塞窗口
set_initial_congestion_window() {
    info "设置初始拥塞窗口..."
    
    # 获取默认路由
    iproute=$(ip -o -4 route show to default)
    if [[ -z "$iproute" ]]; then
        fail "无法检测到默认路由"
        return 1
    fi
    
    # 设置初始拥塞窗口
    ip route change $iproute initcwnd 25 initrwnd 25
    if [ $? -ne 0 ]; then
        warn "初始拥塞窗口设置失败"
    else
        info_2 "初始拥塞窗口设置为 initcwnd 25 initrwnd 25"
    fi
    
    # 显示当前设置
    info "当前初始拥塞窗口设置:"
    ip route show | grep default || warn "无法获取初始拥塞窗口信息"
    
    info "初始拥塞窗口设置完成"
    return 0
}

# 禁用TSO/GSO/GRO
disable_tso() {
    info "禁用TSO/GSO/GRO..."
    
    # 获取主网络接口
    interface=$(ip -o -4 route show to default | awk '{print $5}' | head -n1)
    if [[ -z "$interface" ]]; then
        fail "无法检测到网络接口"
        return 1
    fi
    
    if [ -z "$(which ethtool)" ]; then
        info "安装ethtool..."
        apt-get -y install ethtool
        if [ $? -ne 0 ]; then
            fail "Ethtool安装失败"
            return 1
        fi
    fi
    
    # 禁用TSO/GSO/GRO
    ethtool -K $interface tso off gso off gro off 2>/dev/null
    if [ $? -ne 0 ]; then
        warn "禁用TSO/GSO/GRO失败"
    else
        info_2 "网络接口 $interface 的 TSO/GSO/GRO 已禁用"
    fi
    sleep 1
    
    # 显示当前设置
    info "当前TSO/GSO/GRO设置:"
    ethtool -k $interface | grep -E 'tcp-segmentation-offload|generic-segmentation-offload|generic-receive-offload' || warn "无法获取TSO/GSO/GRO信息"
    
    info "TSO/GSO/GRO设置完成"
    return 0
} 


# BBR安装模块
# 检测操作系统
detect_os() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS=$NAME
        VER=$VERSION_ID
    elif type lsb_release >/dev/null 2>&1; then
        OS=$(lsb_release -si)
        VER=$(lsb_release -sr)
    elif [ -f /etc/lsb-release ]; then
        . /etc/lsb-release
        OS=$DISTRIB_ID
        VER=$DISTRIB_RELEASE
    elif [ -f /etc/debian_version ]; then
        OS=Debian
        VER=$(cat /etc/debian_version)
    else
        OS=$(uname -s)
        VER=$(uname -r)
    fi

    info "检测到操作系统: $OS $VER"
    return 0
}

# 安装BBRx
install_bbrx() {
    info "安装BBRx..."
    
    # 检测操作系统
    detect_os
    
    # 安装内核
    if [[ "$OS" =~ "Debian" ]]; then
        if [ $(uname -m) == "x86_64" ]; then
            info "安装amd64内核..."
            apt-get -y install linux-image-amd64 linux-headers-amd64
            if [ $? -ne 0 ]; then
                fail "BBR内核安装失败"
                return 1
            fi
        elif [ $(uname -m) == "aarch64" ]; then
            info "安装arm64内核..."
            apt-get -y install linux-image-arm64 linux-headers-arm64
            if [ $? -ne 0 ]; then
                fail "BBR内核安装失败"
                return 1
            fi
        fi
    elif [[ "$OS" =~ "Ubuntu" ]]; then
        info "安装通用内核..."
        apt-get -y install linux-image-generic linux-headers-generic
        if [ $? -ne 0 ]; then
            fail "BBR内核安装失败"
            return 1
        fi
    else
        fail "不支持的操作系统"
        return 1
    fi
    
    # 下载BBRx脚本
    info "下载BBRx脚本..."
    wget https://raw.githubusercontent.com/guowanghushifu/Seedbox-Components/main/BBR/BBRx/BBRx.sh -O /root/BBRx.sh
    if [ ! -f /root/BBRx.sh ]; then
        fail "BBRx下载失败"
        return 1
    fi
    
    chmod +x /root/BBRx.sh
    
    # 创建系统启动服务
    info "创建BBR安装服务..."
    cat > /etc/systemd/system/bbrinstall.service << EOF
[Unit]
Description=BBRinstall
After=network.target

[Service]
Type=oneshot
ExecStart=/root/BBRx.sh
RemainAfterExit=true

[Install]
WantedBy=multi-user.target
EOF
    
    systemctl enable bbrinstall.service
    
    info "BBRx安装完成，重启后生效"
    need_input "是否现在重启服务器？(y/n)"
    read reboot_now
    if [[ "$reboot_now" == "y" || "$reboot_now" == "Y" ]]; then
        info "正在重启服务器..."
        reboot
    else
        info "请稍后手动重启服务器以应用BBRx"
    fi
    
    return 0
}

# 安装BBRy
install_bbry() {
    info "安装BBRy..."
    
    # 检测操作系统
    detect_os
    
    # 安装内核
    if [[ "$OS" =~ "Debian" ]]; then
        if [ $(uname -m) == "x86_64" ]; then
            info "安装amd64内核..."
            apt-get -y install linux-image-amd64 linux-headers-amd64
            if [ $? -ne 0 ]; then
                fail "BBR内核安装失败"
                return 1
            fi
        elif [ $(uname -m) == "aarch64" ]; then
            info "安装arm64内核..."
            apt-get -y install linux-image-arm64 linux-headers-arm64
            if [ $? -ne 0 ]; then
                fail "BBR内核安装失败"
                return 1
            fi
        fi
    elif [[ "$OS" =~ "Ubuntu" ]]; then
        info "安装通用内核..."
        apt-get -y install linux-image-generic linux-headers-generic
        if [ $? -ne 0 ]; then
            fail "BBR内核安装失败"
            return 1
        fi
    else
        fail "不支持的操作系统"
        return 1
    fi
    
    # 下载BBRy脚本
    info "下载BBRy脚本..."
    wget https://raw.githubusercontent.com/guowanghushifu/Seedbox-Components/main/BBR/BBRx/BBRy.sh -O /root/BBRy.sh
    if [ ! -f /root/BBRy.sh ]; then
        fail "BBRy下载失败"
        return 1
    fi
    
    chmod +x /root/BBRy.sh
    
    # 创建系统启动服务
    info "创建BBR安装服务..."
    cat > /etc/systemd/system/bbrinstall.service << EOF
[Unit]
Description=BBRinstall
After=network.target

[Service]
Type=oneshot
ExecStart=/root/BBRy.sh
RemainAfterExit=true

[Install]
WantedBy=multi-user.target
EOF
    
    systemctl enable bbrinstall.service
    
    info "BBRy安装完成，重启后生效"
    need_input "是否现在重启服务器？(y/n)"
    read reboot_now
    if [[ "$reboot_now" == "y" || "$reboot_now" == "Y" ]]; then
        info "正在重启服务器..."
        reboot
    else
        info "请稍后手动重启服务器以应用BBRy"
    fi
    
    return 0
}

# 安装BBRz
install_bbrz() {
    info "安装BBRz..."
    
    # 检测操作系统
    detect_os
    
    # 安装内核
    if [[ "$OS" =~ "Debian" ]]; then
        if [ $(uname -m) == "x86_64" ]; then
            info "安装amd64内核..."
            apt-get -y install linux-image-amd64 linux-headers-amd64
            if [ $? -ne 0 ]; then
                fail "BBR内核安装失败"
                return 1
            fi
        elif [ $(uname -m) == "aarch64" ]; then
            info "安装arm64内核..."
            apt-get -y install linux-image-arm64 linux-headers-arm64
            if [ $? -ne 0 ]; then
                fail "BBR内核安装失败"
                return 1
            fi
        fi
    elif [[ "$OS" =~ "Ubuntu" ]]; then
        info "安装通用内核..."
        apt-get -y install linux-image-generic linux-headers-generic
        if [ $? -ne 0 ]; then
            fail "BBR内核安装失败"
            return 1
        fi
    else
        fail "不支持的操作系统"
        return 1
    fi
    
    # 下载BBRz脚本
    info "下载BBRz脚本..."
    wget https://raw.githubusercontent.com/guowanghushifu/Seedbox-Components/main/BBR/BBRx/BBRz.sh -O /root/BBRz.sh
    if [ ! -f /root/BBRz.sh ]; then
        fail "BBRz下载失败"
        return 1
    fi
    
    chmod +x /root/BBRz.sh
    
    # 创建系统启动服务
    info "创建BBR安装服务..."
    cat > /etc/systemd/system/bbrinstall.service << EOF
[Unit]
Description=BBRinstall
After=network.target

[Service]
Type=oneshot
ExecStart=/root/BBRz.sh
RemainAfterExit=true

[Install]
WantedBy=multi-user.target
EOF
    
    systemctl enable bbrinstall.service
    
    info "BBRz安装完成，重启后生效"
    need_input "是否现在重启服务器？(y/n)"
    read reboot_now
    if [[ "$reboot_now" == "y" || "$reboot_now" == "Y" ]]; then
        info "正在重启服务器..."
        reboot
    else
        info "请稍后手动重启服务器以应用BBRz"
    fi
    
    return 0
}

# 安装BBRv3
install_bbrv3() {
    warn "注意：BBRv3当前可能不稳定，使用前请确保已备份重要数据"
    need_input "是否继续？(y/n)"
    read continue_install
    if [[ "$continue_install" != "y" && "$continue_install" != "Y" ]]; then
        info "已取消BBRv3安装"
        return 0
    fi
    
    info "安装BBRv3..."
    
    # 检测处理器架构
    if [ $(uname -m) == "x86_64" ]; then
        info "检测到x86_64架构"
        
        # 下载内核包
        info "下载BBRv3内核包..."
        wget https://raw.githubusercontent.com/guowanghushifu/Seedbox-Components/main/BBR/BBRv3/x86_64/linux-headers-6.4.0+-amd64.deb -O /tmp/linux-headers-6.4.0+-amd64.deb
        if [ ! -f /tmp/linux-headers-6.4.0+-amd64.deb ]; then
            fail "BBRv3内核头文件下载失败"
            return 1
        fi
        
        wget https://raw.githubusercontent.com/guowanghushifu/Seedbox-Components/main/BBR/BBRv3/x86_64/linux-image-6.4.0+-amd64.deb -O /tmp/linux-image-6.4.0+-amd64.deb
        if [ ! -f /tmp/linux-image-6.4.0+-amd64.deb ]; then
            fail "BBRv3内核镜像下载失败"
            rm /tmp/linux-headers-6.4.0+-amd64.deb
            return 1
        fi
        
        wget https://raw.githubusercontent.com/guowanghushifu/Seedbox-Components/main/BBR/BBRv3/x86_64/linux-libc-dev_-6.4.0-amd64.deb -O /tmp/linux-libc-dev_-6.4.0-amd64.deb
        if [ ! -f /tmp/linux-libc-dev_-6.4.0-amd64.deb ]; then
            fail "BBRv3 libc开发包下载失败"
            rm /tmp/linux-headers-6.4.0+-amd64.deb /tmp/linux-image-6.4.0+-amd64.deb
            return 1
        fi
        
        # 安装内核包
        info "安装BBRv3内核包..."
        apt-get install -y /tmp/linux-headers-6.4.0+-amd64.deb /tmp/linux-image-6.4.0+-amd64.deb /tmp/linux-libc-dev_-6.4.0-amd64.deb
        if [ $? -ne 0 ]; then
            fail "BBRv3内核安装失败"
            rm /tmp/linux-headers-6.4.0+-amd64.deb /tmp/linux-image-6.4.0+-amd64.deb /tmp/linux-libc-dev_-6.4.0-amd64.deb
            return 1
        fi
        
        # 清理下载文件
        rm /tmp/linux-headers-6.4.0+-amd64.deb /tmp/linux-image-6.4.0+-amd64.deb /tmp/linux-libc-dev_-6.4.0-amd64.deb
        
    elif [ $(uname -m) == "aarch64" ]; then
        info "检测到ARM64架构"
        
        # 下载内核包
        info "下载BBRv3内核包..."
        wget https://raw.githubusercontent.com/guowanghushifu/Seedbox-Components/main/BBR/BBRv3/ARM64/linux-headers-6.4.0+-arm64.deb -O /tmp/linux-headers-6.4.0+-arm64.deb
        if [ ! -f /tmp/linux-headers-6.4.0+-arm64.deb ]; then
            fail "BBRv3内核头文件下载失败"
            return 1
        fi
        
        wget https://raw.githubusercontent.com/guowanghushifu/Seedbox-Components/main/BBR/BBRv3/ARM64/linux-image-6.4.0+-arm64.deb -O /tmp/linux-image-6.4.0+-arm64.deb
        if [ ! -f /tmp/linux-image-6.4.0+-arm64.deb ]; then
            fail "BBRv3内核镜像下载失败"
            rm /tmp/linux-headers-6.4.0+-arm64.deb
            return 1
        fi
        
        wget https://raw.githubusercontent.com/guowanghushifu/Seedbox-Components/main/BBR/BBRv3/ARM64/linux-libc-dev_-6.4.0-arm64.deb -O /tmp/linux-libc-dev_-6.4.0-arm64.deb
        if [ ! -f /tmp/linux-libc-dev_-6.4.0-arm64.deb ]; then
            fail "BBRv3 libc开发包下载失败"
            rm /tmp/linux-headers-6.4.0+-arm64.deb /tmp/linux-image-6.4.0+-arm64.deb
            return 1
        fi
        
        # 安装内核包
        info "安装BBRv3内核包..."
        apt-get install -y /tmp/linux-headers-6.4.0+-arm64.deb /tmp/linux-image-6.4.0+-arm64.deb /tmp/linux-libc-dev_-6.4.0-arm64.deb
        if [ $? -ne 0 ]; then
            fail "BBRv3内核安装失败"
            rm /tmp/linux-headers-6.4.0+-arm64.deb /tmp/linux-image-6.4.0+-arm64.deb /tmp/linux-libc-dev_-6.4.0-arm64.deb
            return 1
        fi
        
        # 清理下载文件
        rm /tmp/linux-headers-6.4.0+-arm64.deb /tmp/linux-image-6.4.0+-arm64.deb /tmp/linux-libc-dev_-6.4.0-arm64.deb
        
    else
        fail "不支持的处理器架构: $(uname -m)"
        return 1
    fi
    
    # 配置BBRv3
    info "配置BBRv3..."
    cat > /etc/sysctl.d/99-bbr-v3.conf << EOF
# BBRv3配置
net.core.default_qdisc = fq
net.ipv4.tcp_congestion_control = bbr
EOF
    
    sysctl -p /etc/sysctl.d/99-bbr-v3.conf
    
    info "BBRv3安装完成，需要重启服务器以应用"
    need_input "是否现在重启服务器？(y/n)"
    read reboot_now
    if [[ "$reboot_now" == "y" || "$reboot_now" == "Y" ]]; then
        info "正在重启服务器..."
        reboot
    else
        info "请稍后手动重启服务器以应用BBRv3"
    fi
    
    return 0
} 


# 主函数
main() {
    clear
    need_input "警告：此脚本会修改系统设置，使用前请确保已备份重要数据!"
    need_input "按Enter键继续..."
    read
    
    # 检查root权限
    if [ "$(id -u)" -ne 0 ]; then
        fail_exit "请使用root权限运行此脚本"
    fi
    
    # 更新系统
    update
    
    while true; do
        clear
        seperator
        info "PT服务器安装和优化脚本"
        seperator
        
        echo " 软件安装"
        echo " 1) 安装qBittorrent"
        echo " 2) 安装AutoBrr"
        echo " 3) 安装Vertex"
        echo " 4) 安装autoremove-torrents"
        echo
        echo " 系统优化"
        echo " 5) 优化内核参数"
        echo " 6) 设置文件打开限制"
        echo " 7) 优化磁盘调度器"
        echo " 8) 安装tuned"
        echo
        echo " 网络优化"
        echo " 9) 优化网络设置"
        echo "10) 设置Ring Buffer"
        echo "11) 设置txqueuelen"
        echo "12) 设置初始拥塞窗口"
        echo "13) 禁用TSO/GSO/GRO"
        echo
        echo " BBR安装"
        echo "14) 安装BBRx"
        echo "15) 安装BBRy"
        echo "16) 安装BBRz"
        echo "17) 安装BBRv3"
        echo
        echo "18) 一键优化(5-13)"
        echo "19) 退出"
        
        need_input "请选择操作 [1-19]:"
        read choice
        
        case $choice in
            1) install_qbittorrent ;;
            2) install_autobrr ;;
            3) install_vertex ;;
            4) install_autoremove_torrents ;;
            5) kernel_settings ;;
            6) set_file_open_limit ;;
            7) set_disk_scheduler ;;
            8) tuned ;;
            9) optimize_network ;;
            10) set_ring_buffer ;;
            11) set_txqueuelen ;;
            12) set_initial_congestion_window ;;
            13) disable_tso ;;
            14) install_bbrx ;;
            15) install_bbry ;;
            16) install_bbrz ;;
            17) install_bbrv3 ;;
            18)
                kernel_settings
                set_file_open_limit
                set_disk_scheduler
                tuned
                optimize_network
                set_ring_buffer
                set_txqueuelen
                set_initial_congestion_window
                disable_tso
                ;;
            19) 
                info "谢谢使用！"
                exit 0
                ;;
            *) warn "无效选择，请重试!" ;;
        esac
        
        echo
        need_input "按Enter键继续..."
        read
    done
}

# 执行主函数
main
